# Internationalization (i18n) Guide

This guide explains how to use the i18n system in @je-es/server.

## Overview

The i18n module provides a simple yet powerful way to manage translations across your application. It supports:

- Multiple languages (English, Arabic, French out of the box)
- Smart parameter replacement with nested translation keys
- Language detection from query params, headers, or cookies
- Per-request language context

## File Structure

```
static/i18n/
├── en.json    # English translations
├── ar.json    # Arabic translations
└── fr.json    # French translations
```

## Translation File Format

Each translation file is a JSON object with dot-notation keys:

```json
{
  "app.name": "My App",
  "error.notFound": "Resource not found",
  "validation.invalid": "Invalid value for {field}",
  "message.greeting": "Hello {name}, welcome to {app}"
}
```

## Server Configuration

Enable i18n in your server configuration:

```typescript
import server from '@je-es/server';

const app = server({
  port: 3000,
  i18n: {
    defaultLanguage: 'en',
    supportedLanguages: ['en', 'ar', 'fr'],
    staticPath: 'static/i18n'  // Path to translation files
  }
});

app.start();
```

Or use the default configuration:

```typescript
const app = server({
  port: 3000,
  i18n: true  // Uses defaults
});
```

## Usage in Route Handlers

### Basic Translation

```typescript
const route = {
  method: 'GET',
  path: '/api/info',
  handler: (c) => {
    const appName = c.i18n?.t('app.name');
    return c.json({ name: appName });
  }
};
```

### Translation with Parameters

Parameters are replaced in the translation string using curly braces `{param}`:

```typescript
const route = {
  method: 'GET',
  path: '/api/error',
  handler: (c) => {
    const message = c.i18n?.t('validation.invalid', {
      field: 'email'
    });
    // Result: "Invalid value for email"
    return c.json({ error: message });
  }
};
```

### Nested Translation Keys as Parameters

You can pass translation keys as parameter values, and they will be resolved:

```typescript
const message = c.i18n?.t('message.greeting', {
  name: 'John',
  app: 'app.name'  // This will be translated
});
// Assuming app.name = "My App"
// Result: "Hello John, welcome to My App"
```

### Language Detection

The system automatically detects the language from:
1. **Query parameter**: `?lang=ar`
2. **Accept-Language header**: `Accept-Language: ar-SA,ar;q=0.9`
3. **Default language**: Falls back to configured default

```typescript
// Client request: GET /api/info?lang=ar
// The handler will use Arabic translations automatically
```

### Explicit Language Control

You can also set the language explicitly:

```typescript
const route = {
  method: 'GET',
  path: '/api/info/:lang',
  handler: (c) => {
    const lang = c.params.lang;  // 'ar', 'en', 'fr', etc.

    // Translations for the current language
    const currentLangMessage = c.i18n?.t('app.name');

    // Translations for specific language
    const specificLangMessage = c.i18n?.tLang('app.name', lang);

    return c.json({
      current: currentLangMessage,
      specific: specificLangMessage
    });
  }
};
```

## Global i18n Functions

If you need to use i18n outside of request context:

```typescript
import {
  initI18n,
  getI18n,
  t,
  setLanguage,
  getCurrentLanguage,
  getSupportedLanguages
} from '@je-es/server';

// Initialize i18n
const i18n = initI18n({
  defaultLanguage: 'en',
  supportedLanguages: ['en', 'ar', 'fr']
});

// Load translations
i18n.loadLanguage('en', {
  'app.name': 'My App',
  'app.version': '1.0.0'
});

// Translate
const message = t('app.name');

// Set current language
setLanguage('ar');

// Get current language
const lang = getCurrentLanguage();

// Get supported languages
const langs = getSupportedLanguages();
```

## Advanced Examples

### Multi-language Error Handler

```typescript
const app = server({
  port: 3000,
  i18n: true,
  errorHandler: async (error, c) => {
    let message = error.message;

    if (error.code === 'VALIDATION_ERROR') {
      message = c.i18n?.t('error.validation') || 'Validation failed';
    }

    return c.status(error.statusCode || 500).json({
      error: message,
      code: error.code,
      requestId: c.requestId
    });
  }
});
```

### Middleware for Language Header

```typescript
const languageMiddleware: AppMiddleware = async (c, next) => {
  // Set language from header or query
  const lang = c.query.lang || c.getHeader('x-language') || c.lang;
  c.i18n?.setLanguage(lang);

  await next();
};
```

### Translating Collections

```typescript
const route = {
  method: 'GET',
  path: '/api/errors',
  handler: (c) => {
    const errors = [
      { key: 'error.notFound', message: '' },
      { key: 'error.unauthorized', message: '' },
      { key: 'error.forbidden', message: '' }
    ];

    // Translate all error messages
    const translated = errors.map(err => ({
      ...err,
      message: c.i18n?.t(err.key)
    }));

    return c.json(translated);
  }
};
```

## Best Practices

1. **Use dot notation for keys**: `feature.action.status` is better than `feature_action_status`

2. **Keep translations simple**: Avoid logic in templates

3. **Use parameters for dynamic values**: Don't concatenate strings

4. **Provide fallbacks**: Always have English translations as fallback

5. **Load translations early**: Load all translations during server startup

6. **Cache translations**: Once loaded, translations are cached in memory

7. **Test translations**: Ensure all keys exist in all languages

## Adding New Languages

1. Create a new translation file:
```json
// static/i18n/es.json
{
  "app.name": "Mi Aplicación",
  "app.version": "0.2.1",
  ...
}
```

2. Add to supported languages:
```typescript
const app = server({
  i18n: {
    supportedLanguages: ['en', 'ar', 'fr', 'es']
  }
});
```

3. Load the new language:
```typescript
const esFile = Bun.file('static/i18n/es.json');
const esData = await esFile.json();
i18n.loadLanguage('es', esData);
```

## Performance Considerations

- Translations are loaded into memory at startup
- Parameter replacement uses regex with global flag for efficiency
- Language switching is O(1) operation
- No external API calls needed

## Troubleshooting

### Missing Translations
If a translation key is not found:
1. It tries the default language
2. If still not found, it returns the key itself
3. Check console logs for missing keys

### Language Not Detected
- Ensure the language code matches your translation files
- Check the `Accept-Language` header format
- Use query parameter `?lang=xx` to override

### Performance Issues
- Ensure translation files are not too large
- Consider splitting into multiple files for very large applications
- Cache translated responses if possible
